package com.scythe.instrumenter.mutation;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import com.scythe.instrumenter.InstrumentationProperties.Parameter;
import com.scythe.instrumenter.PropertySource;

public class MutationProperties implements PropertySource {

    @Parameter(key = "active_mutant_file", description = "File containing IDs of active mutants for mutation testing", hasArgs = true, category = "Mutation")
    public static String ACTIVE_MUTANT_FILE = "";

    @Parameter(key = "visit_mutants", description = "Whether or not to use mutants generated by a mutant-generation tool", hasArgs = true, category = "Mutation")
    public static boolean VISIT_MUTANTS = false;

    @Parameter(key = "major_root", description = "When using mutants, it is necessary to have the major jar file on the class path. This property represents the path to major", hasArgs = true, category = "Mutation")
    public static String MAJOR_ROOT = "";

    protected Map<String, Field> parameterMap = new HashMap<String, Field>();
    protected Map<String, Parameter> annotationMap = new HashMap<String, Parameter>();
    protected Map<String, ArrayList<String>> categoryMap = new HashMap<String, ArrayList<String>>();

    private void reflectMap() {
        for (Field field : Arrays.asList(getClass().getFields())) {
            if (field.isAnnotationPresent(Parameter.class)) {
                Parameter p = field.getAnnotation(Parameter.class);
                String key = p.key();
                parameterMap.put(key, field);
                annotationMap.put(key, p);
                if (categoryMap.containsKey(p.category())) {
                    categoryMap.get(p.category()).add(key);
                } else {
                    ArrayList<String> cats = new ArrayList<String>();
                    cats.add(key);
                    categoryMap.put(p.category(), cats);
                }

            }
        }
    }

    protected MutationProperties() {
        reflectMap();
    }

    @Override
    public boolean hasParameter(String name) {
        return parameterMap.keySet().contains(name);
    }

    @Override
    public Set<String> getParameterNames() {
        return parameterMap.keySet();
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    public void setParameter(String name, String value) throws IllegalAccessException {
        if (!parameterMap.containsKey(name)) {
            throw new IllegalArgumentException(name + " was not found in the InstrumentationProperties class");
        }
        Field f = parameterMap.get(name);
        Class<?> cl = f.getType();
        if (cl.isAssignableFrom(Number.class) || cl.isPrimitive()) {
            if (cl.equals(Long.class) || cl.equals(long.class)) {
                try {
                    Long l = Long.parseLong(value);
                    f.setLong(null, l);
                } catch (NumberFormatException e) {
                    Double fl = Double.parseDouble(value);
                    f.setLong(null, (long) fl.doubleValue());
                }
            } else if (cl.equals(Double.class) || cl.equals(double.class)) {
                Double d = Double.parseDouble(value);
                f.setDouble(null, d);
            } else if (cl.equals(Float.class) || cl.equals(float.class)) {
                Float fl = Float.parseFloat(value);
                f.setFloat(null, fl);
            } else if (cl.equals(Integer.class) || cl.equals(int.class)) {
                Double fl = Double.parseDouble(value);
                f.setInt(null, (int) fl.doubleValue());
            } else if (cl.equals(Boolean.class) || cl.equals(boolean.class)) {
                Boolean bl = Boolean.parseBoolean(value);
                f.setBoolean(null, bl);
            }
        } else if (cl.isAssignableFrom(String.class)) {
            f.set(null, value);
        }
        if (f.getType().isEnum()) {
            f.set(null, Enum.valueOf((Class<Enum>) f.getType(), value.toUpperCase()));
        }
    }

    private static MutationProperties instance;

    public static MutationProperties instance() {
        if (instance == null) {
            instance = new MutationProperties();
        }
        return instance;
    }

}
