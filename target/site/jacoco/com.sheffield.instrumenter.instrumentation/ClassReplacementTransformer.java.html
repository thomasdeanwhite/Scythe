<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassReplacementTransformer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Light-weight Instrumentation</a> &gt; <a href="index.source.html" class="el_package">com.sheffield.instrumenter.instrumentation</a> &gt; <span class="el_source">ClassReplacementTransformer.java</span></div><h1>ClassReplacementTransformer.java</h1><pre class="source lang-java linenums">package com.sheffield.instrumenter.instrumentation;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.instrument.IllegalClassFormatException;
import java.util.ArrayList;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.JSRInlinerAdapter;

import com.sheffield.instrumenter.InstrumentationProperties;
import com.sheffield.instrumenter.InstrumentationProperties.InstrumentationApproach;
import com.sheffield.instrumenter.analysis.ClassAnalyzer;
import com.sheffield.instrumenter.analysis.InstrumentingTask;
import com.sheffield.instrumenter.analysis.task.Task;
import com.sheffield.instrumenter.analysis.task.TaskTimer;
import com.sheffield.util.ClassNameUtils;

public class ClassReplacementTransformer {

<span class="fc" id="L28">    private static ArrayList&lt;String&gt; seenClasses = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L29">    private boolean shouldWriteClass = false;</span>
    public ArrayList&lt;ShouldInstrumentChecker&gt; shouldInstrumentCheckers;

    public interface ShouldInstrumentChecker {
        boolean shouldInstrument(String className);
    }

<span class="fc" id="L36">    public ClassReplacementTransformer() {</span>
<span class="fc" id="L37">        shouldInstrumentCheckers = new ArrayList&lt;ShouldInstrumentChecker&gt;();</span>
<span class="fc" id="L38">        shouldInstrumentCheckers.add(new ShouldInstrumentChecker() {</span>
            @Override
            public boolean shouldInstrument(String className) {
<span class="pc bpc" id="L41" title="1 of 2 branches missed.">                return InstrumentationProperties.INSTRUMENTATION_APPROACH != InstrumentationApproach.NONE;</span>
            }
        });

<span class="fc" id="L45">        shouldInstrumentCheckers.add(new ShouldInstrumentChecker() {</span>
            @Override
            public boolean shouldInstrument(String className) {
<span class="pc bpc" id="L48" title="1 of 2 branches missed.">                if (className == null) {</span>
<span class="nc" id="L49">                    return false;</span>
                }
<span class="fc bfc" id="L51" title="All 2 branches covered.">                if (isForbiddenPackage(className)) {</span>
<span class="fc" id="L52">                    return false;</span>
                }
<span class="fc" id="L54">                return true;</span>
            }
        });
<span class="fc" id="L57">    }</span>

    public void setWriteClasses(boolean b) {
<span class="nc" id="L60">        shouldWriteClass = b;</span>
<span class="nc" id="L61">    }</span>

    public byte[] transform(String cName, byte[] cBytes, ClassVisitor cv, ClassWriter cw)
            throws IllegalClassFormatException {
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">        if (seenClasses.contains(cName)) {</span>
<span class="nc" id="L66">            throw new IllegalClassFormatException(&quot;Class already loaded!&quot;);</span>
        }
<span class="fc" id="L68">        seenClasses.add(cName);</span>

        // if (InstrumentationProperties.EXILED_CLASSES != null) {
        // for (String s : Properties.EXILED_CLASSES) {
        // if (cName.equals(s)) {
        // // App.out.println(&quot;Not loaded class &quot; + cName);
        // throw new IllegalClassFormatException();
        // }
        // }
        // }

        // App.out.println(&quot;Loaded class &quot; + cName);
        try {
<span class="pc bpc" id="L81" title="1 of 2 branches missed.">            if (!shouldInstrumentClass(cName)) {</span>
<span class="nc" id="L82">                return cBytes;</span>
            }

            // if (iClass == null) {
            // iClass = TestingClassLoader.getClassLoader().loadClass(cName,
            // cBytes);
            // }

            // iClass.

<span class="fc" id="L92">            InputStream ins = new ByteArrayInputStream(cBytes);</span>
<span class="fc" id="L93">            byte[] newClass = cBytes;</span>
            try {
<span class="fc" id="L95">                ClassReader cr = new ClassReader(ins);</span>
<span class="fc" id="L96">                Task instrumentingTask = new InstrumentingTask(cName);</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">                if (InstrumentationProperties.LOG) {</span>
<span class="fc" id="L98">                    TaskTimer.taskStart(instrumentingTask);</span>
                }
                // Handle JSR instructions
<span class="fc" id="L101">                cv = new ClassVisitor(Opcodes.ASM5, cv) {</span>
                    @Override
                    public MethodVisitor visitMethod(int access, String name, String desc, String signature,
                            String[] exceptions) {
<span class="fc" id="L105">                        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);</span>
<span class="fc" id="L106">                        return new JSRInlinerAdapter(mv, access, name, desc, signature, exceptions);</span>
                    }
                };
                try {
<span class="fc" id="L110">                    cr.accept(cv, ClassReader.EXPAND_FRAMES);</span>
<span class="nc" id="L111">                } catch (Throwable t) {</span>
<span class="nc" id="L112">                    t.printStackTrace(ClassAnalyzer.out);</span>
<span class="fc" id="L113">                }</span>
<span class="fc" id="L114">                newClass = cw.toByteArray();</span>

<span class="pc bpc" id="L116" title="1 of 2 branches missed.">                if (InstrumentationProperties.LOG) {</span>
<span class="fc" id="L117">                    TaskTimer.taskEnd(instrumentingTask);</span>
                }
<span class="nc" id="L119">            } catch (IOException e) {</span>
<span class="nc" id="L120">                e.printStackTrace(ClassAnalyzer.out);</span>
<span class="fc" id="L121">            }</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">            if (shouldWriteClass) {</span>
<span class="nc" id="L123">                File file = new File(&quot;classes/&quot; + cName.replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;);</span>
<span class="nc" id="L124">                file.getParentFile().mkdirs();</span>
<span class="nc" id="L125">                file.createNewFile();</span>
<span class="nc" id="L126">                FileOutputStream fos = new FileOutputStream(file.getAbsolutePath());</span>
<span class="nc" id="L127">                fos.write(newClass);</span>
<span class="nc" id="L128">                fos.close();</span>
            }
<span class="fc" id="L130">            return newClass;</span>
<span class="nc" id="L131">        } catch (Exception e) {</span>
<span class="nc" id="L132">            e.printStackTrace(ClassAnalyzer.out);</span>
<span class="nc" id="L133">            return cw.toByteArray();</span>

        }

    }

<span class="fc" id="L139">    private static final ArrayList&lt;String&gt; forbiddenPackages = new ArrayList&lt;String&gt;();</span>

    static {
<span class="fc" id="L142">        String[] defaultHiddenPackages = new String[] { &quot;com/sun&quot;, &quot;java/&quot;, &quot;sun/&quot;, &quot;jdk/&quot;,</span>
                &quot;com/sheffield/instrumenter&quot;, &quot;org/eclipse&quot; };

        // String[] defaultHiddenPackages = new
        // String[]{&quot;com/sheffield/leapmotion&quot;, &quot;com/google/gson&quot;,
        // &quot;com/sun&quot;, &quot;java/&quot;, &quot;sun/&quot;, &quot;com/leapmotion&quot;, &quot;jdk/&quot;, &quot;javax/&quot;,
        // &quot;org/json&quot;, &quot;org/apache/commons/cli&quot;,
        // &quot;com/sheffield/instrumenter&quot;, &quot;com/dpaterson&quot;, &quot;org/junit&quot;};

<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (String s : defaultHiddenPackages) {</span>
<span class="fc" id="L152">            forbiddenPackages.add(s);</span>
        }
<span class="fc" id="L154">    }</span>

    /**
     * Add a package that should not be instrumented.
     *
     * @param forbiddenPackage
     *            the package name not to be instrumented, using / for subpackages (e.g. org/junit)
     */
    public static void addForbiddenPackage(String forbiddenPackage) {
<span class="nc" id="L163">        forbiddenPackages.add(forbiddenPackage);</span>
<span class="nc" id="L164">    }</span>

    public boolean shouldInstrumentClass(String className) {
<span class="fc" id="L167">        className = ClassNameUtils.standardise(className);</span>

<span class="fc bfc" id="L169" title="All 2 branches covered.">        for (ShouldInstrumentChecker sic : shouldInstrumentCheckers) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">            if (!sic.shouldInstrument(className)) {</span>
<span class="fc" id="L171">                return false;</span>
            }
<span class="fc" id="L173">        }</span>

<span class="fc" id="L175">        return true;</span>
    }

    public void addShouldInstrumentChecker(ShouldInstrumentChecker s) {
<span class="nc" id="L179">        shouldInstrumentCheckers.add(s);</span>
<span class="nc" id="L180">    }</span>

    public void removeShouldInstrumentChecker(ShouldInstrumentChecker s) {
<span class="nc" id="L183">        shouldInstrumentCheckers.remove(s);</span>
<span class="nc" id="L184">    }</span>

    public static boolean isForbiddenPackage(String clazz) {
<span class="fc bfc" id="L187" title="All 2 branches covered.">        for (String s : forbiddenPackages) {</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">            if (clazz.startsWith(ClassNameUtils.standardise(s))) {</span>
<span class="fc" id="L189">                return true;</span>
            }
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>